<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de C√°lculo Vectorial - Versi√≥n Completa</title>
    
    <!-- MathJax Configuration (MUST be before loading MathJax) -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']]
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    console.log('MathJax is ready!');
                }
            }
        };
    </script>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
    
    <style>
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1e293b;
            --light: #f8fafc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 20px 20px 0 0;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            min-height: 600px;
        }

        .sidebar {
            background: var(--light);
            padding: 20px;
            border-right: 2px solid #e2e8f0;
        }

        .content {
            padding: 30px;
        }

        .theorem-btn {
            width: 100%;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .theorem-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        .theorem-btn.active {
            background: var(--primary);
            color: white;
        }

        .authors-box {
            background: linear-gradient(135deg, #6366f1, #a855f7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .author {
            padding: 8px;
            background: rgba(255,255,255,0.1);
            margin: 5px 0;
            border-radius: 5px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #64748b;
        }

        .tab.active {
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #475569;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1em;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .result-box {
            background: var(--light);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .step {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid var(--primary);
        }

        .step-title {
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .math-display {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            overflow-x: auto;
        }

        .result-value {
            font-size: 1.3em;
            font-weight: 700;
            color: var(--primary);
            background: rgba(59, 130, 246, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .plot-container {
            width: 100%;
            height: 500px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin: 20px 0;
        }

        .validation-success {
            background: #dcfce7;
            border: 2px solid #86efac;
            color: #166534;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéì Calculadora de C√°lculo Vectorial</h1>
            <p>Resuelve y grafica integrales de Green, Stokes, Divergencia y Superficie</p>
        </div>

        <div class="main-grid">
            <div class="sidebar">
                <h3>Selecciona un Teorema</h3>
                <button class="theorem-btn active" onclick="selectTheorem('green', this)">
                    üìó Teorema de Green
                </button>
                <button class="theorem-btn" onclick="selectTheorem('stokes', this)">
                    üìò Teorema de Stokes
                </button>
                <button class="theorem-btn" onclick="selectTheorem('divergence', this)">
                    üìô Teorema de Divergencia
                </button>
                <button class="theorem-btn" onclick="selectTheorem('surface', this)">
                    üìï Integrales de Superficie
                </button>

                <div class="authors-box">
                    <h4 style="text-align: center; margin-bottom: 10px;">üë®‚Äçüíª Desarrolladores</h4>
                    <div class="author">Daniel David Arteaga P√©rez</div>
                    <div class="author">Servio Andres Lora Jaimes</div>
                    <div class="author">Manuel Alejandro Su√°rez Hern√°ndez</div>
                </div>
            </div>

            <div class="content">
                <div class="tabs">
                    <button class="tab active" onclick="selectTab('input', this)">üìù Entrada</button>
                    <button class="tab" onclick="selectTab('solution', this)">üßÆ Soluci√≥n</button>
                    <button class="tab" onclick="selectTab('visualization', this)">üìä Visualizaci√≥n</button>
                    <button class="tab" onclick="selectTab('validation', this)">‚úÖ Validaci√≥n</button>
                </div>

                <!-- Tab de Entrada -->
                <div id="inputTab" class="tab-content active">
                    <!-- Green -->
                    <div id="greenInputs" class="theorem-inputs">
                        <h3>Configuraci√≥n del Teorema de Green</h3>
                        <div class="input-group">
                            <label>Campo P(x,y)</label>
                            <input type="text" id="greenP" value="x^2 - y">
                        </div>
                        <div class="input-group">
                            <label>Campo Q(x,y)</label>
                            <input type="text" id="greenQ" value="x + y^2">
                        </div>
                        <div class="input-group">
                            <label>Tipo de Regi√≥n</label>
                            <select id="greenRegion" onchange="updateGreenParams()">
                                <option value="circle">C√≠rculo</option>
                                <option value="rectangle">Rect√°ngulo</option>
                                <option value="ellipse">Elipse</option>
                            </select>
                        </div>
                        <div id="greenParams">
                            <div class="input-group">
                                <label>Radio</label>
                                <input type="number" id="greenRadius" value="2" step="0.1">
                            </div>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="calculateGreen()">üßÆ Calcular</button>
                            <button class="btn btn-success" onclick="visualizeGreen()">üìä Visualizar</button>
                        </div>
                    </div>

                    <!-- Stokes -->
                    <div id="stokesInputs" class="theorem-inputs" style="display: none;">
                        <h3>Configuraci√≥n del Teorema de Stokes</h3>
                        <div class="input-group">
                            <label>Campo P(x,y,z)</label>
                            <input type="text" id="stokesP" value="y*z">
                        </div>
                        <div class="input-group">
                            <label>Campo Q(x,y,z)</label>
                            <input type="text" id="stokesQ" value="x*z">
                        </div>
                        <div class="input-group">
                            <label>Campo R(x,y,z)</label>
                            <input type="text" id="stokesR" value="x*y">
                        </div>
                        <div class="input-group">
                            <label>Superficie</label>
                            <select id="stokesSurface">
                                <option value="hemisphere">Hemisferio</option>
                                <option value="paraboloid">Paraboloide</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>Radio/Par√°metro</label>
                            <input type="number" id="stokesParam" value="1" step="0.1">
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="calculateStokes()">üßÆ Calcular</button>
                            <button class="btn btn-success" onclick="visualizeStokes()">üìä Visualizar</button>
                        </div>
                    </div>

                    <!-- Divergence -->
                    <div id="divergenceInputs" class="theorem-inputs" style="display: none;">
                        <h3>Configuraci√≥n del Teorema de Divergencia</h3>
                        <div class="input-group">
                            <label>Campo P(x,y,z)</label>
                            <input type="text" id="divP" value="x^2">
                        </div>
                        <div class="input-group">
                            <label>Campo Q(x,y,z)</label>
                            <input type="text" id="divQ" value="y^2">
                        </div>
                        <div class="input-group">
                            <label>Campo R(x,y,z)</label>
                            <input type="text" id="divR" value="z^2">
                        </div>
                        <div class="input-group">
                            <label>Volumen</label>
                            <select id="divVolume">
                                <option value="sphere">Esfera</option>
                                <option value="cube">Cubo</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>Radio/Lado</label>
                            <input type="number" id="divParam" value="1" step="0.1">
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="calculateDivergence()">üßÆ Calcular</button>
                            <button class="btn btn-success" onclick="visualizeDivergence()">üìä Visualizar</button>
                        </div>
                    </div>

                    <!-- Surface -->
                    <div id="surfaceInputs" class="theorem-inputs" style="display: none;">
                        <h3>Configuraci√≥n de Integral de Superficie</h3>
                        <div class="input-group">
                            <label>Tipo</label>
                            <select id="surfaceType" onchange="updateSurfaceInputs()">
                                <option value="scalar">Escalar</option>
                                <option value="flux">Flujo</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>x(u,v)</label>
                            <input type="text" id="surfX" value="u*cos(v)">
                        </div>
                        <div class="input-group">
                            <label>y(u,v)</label>
                            <input type="text" id="surfY" value="u*sin(v)">
                        </div>
                        <div class="input-group">
                            <label>z(u,v)</label>
                            <input type="text" id="surfZ" value="v">
                        </div>
                        <div class="input-group">
                            <label>Rango u</label>
                            <input type="text" id="surfURange" value="0, 2">
                        </div>
                        <div class="input-group">
                            <label>Rango v</label>
                            <input type="text" id="surfVRange" value="0, 2*pi">
                        </div>
                        <div id="scalarInput">
                            <div class="input-group">
                                <label>f(x,y,z)</label>
                                <input type="text" id="scalarFunc" value="x^2 + y^2 + z^2">
                            </div>
                        </div>
                        <div id="fluxInput" style="display: none;">
                            <div class="input-group">
                                <label>F‚ÇÅ(x,y,z)</label>
                                <input type="text" id="fluxF1" value="x">
                            </div>
                            <div class="input-group">
                                <label>F‚ÇÇ(x,y,z)</label>
                                <input type="text" id="fluxF2" value="y">
                            </div>
                            <div class="input-group">
                                <label>F‚ÇÉ(x,y,z)</label>
                                <input type="text" id="fluxF3" value="z">
                            </div>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="calculateSurface()">üßÆ Calcular</button>
                            <button class="btn btn-success" onclick="visualizeSurface()">üìä Visualizar</button>
                        </div>
                    </div>
                </div>

                <!-- Tab de Soluci√≥n -->
                <div id="solutionTab" class="tab-content">
                    <div id="solutionContent"></div>
                </div>

                <!-- Tab de Visualizaci√≥n -->
                <div id="visualizationTab" class="tab-content">
                    <div id="plotContainer" class="plot-container"></div>
                </div>

                <!-- Tab de Validaci√≥n -->
                <div id="validationTab" class="tab-content">
                    <div id="validationContent"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GLOBAL STATE ====================
        let currentTheorem = 'green';

        // ==================== UTILITY FUNCTIONS ====================
        
        /**
         * Safely typeset MathJax content
         */
        function typesetMath() {
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                MathJax.typesetPromise().catch((err) => console.error('MathJax typeset error:', err));
            } else if (typeof MathJax !== 'undefined' && MathJax.typeset) {
                try {
                    MathJax.typeset();
                } catch (err) {
                    console.error('MathJax typeset error:', err);
                }
            }
        }

        /**
         * Parse range string (e.g., "0, 2*pi") to array of numbers
         */
        function parseRange(rangeStr) {
            return rangeStr.split(',').map(s => {
                const val = s.trim();
                if (val.includes('pi')) {
                    const factor = parseFloat(val.replace(/\*?pi/g, '')) || 1;
                    return factor * Math.PI;
                }
                return parseFloat(val);
            });
        }

        /**
         * Evaluate math expression safely
         */
        function evaluateExpression(expr, scope) {
            try {
                return math.evaluate(expr, scope);
            } catch (error) {
                console.error('Math evaluation error:', error);
                return 0;
            }
        }

        // ==================== NAVIGATION ====================
        
        /**
         * Select theorem and update UI
         */
        function selectTheorem(theorem, element) {
            currentTheorem = theorem;
            
            document.querySelectorAll('.theorem-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            element.classList.add('active');
            
            document.querySelectorAll('.theorem-inputs').forEach(input => {
                input.style.display = 'none';
            });
            
            const selectedInput = document.getElementById(theorem + 'Inputs');
            if (selectedInput) {
                selectedInput.style.display = 'block';
            }
        }

        /**
         * Select tab and update UI
         */
        function selectTab(tab, element) {
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.remove('active');
            });
            if (element) element.classList.add('active');
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            const selectedTab = document.getElementById(tab + 'Tab');
            if (selectedTab) {
                selectedTab.classList.add('active');
            }
        }

        // ==================== GREEN THEOREM ====================
        
        /**
         * Update Green parameters based on region type
         */
        function updateGreenParams() {
            const region = document.getElementById('greenRegion').value;
            const params = document.getElementById('greenParams');
            
            if (region === 'circle') {
                params.innerHTML = `
                    <div class="input-group">
                        <label>Radio</label>
                        <input type="number" id="greenRadius" value="2" step="0.1">
                    </div>
                `;
            } else if (region === 'rectangle') {
                params.innerHTML = `
                    <div class="input-group">
                        <label>Ancho</label>
                        <input type="number" id="greenWidth" value="4" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>Alto</label>
                        <input type="number" id="greenHeight" value="3" step="0.1">
                    </div>
                `;
            } else if (region === 'ellipse') {
                params.innerHTML = `
                    <div class="input-group">
                        <label>Semi-eje a</label>
                        <input type="number" id="greenA" value="3" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>Semi-eje b</label>
                        <input type="number" id="greenB" value="2" step="0.1">
                    </div>
                `;
            }
        }

        /**
         * Calculate Green's theorem
         */
        function calculateGreen() {
            const P = document.getElementById('greenP').value;
            const Q = document.getElementById('greenQ').value;
            const region = document.getElementById('greenRegion').value;
            
            try {
                const pExpr = math.parse(P);
                const qExpr = math.parse(Q);
                
                const dQdx = math.derivative(qExpr, 'x');
                const dPdy = math.derivative(pExpr, 'y');
                
                const integrandExpr = `(${dQdx.toString()}) - (${dPdy.toString()})`;
                const integrand = math.simplify(integrandExpr);
                
                let integralValue = 0;
                let area = 0;
                let regionDesc = '';
                
                if (region === 'circle') {
                    const radius = parseFloat(document.getElementById('greenRadius').value);
                    area = Math.PI * radius * radius;
                    regionDesc = `C√≠rculo de radio ${radius}`;
                    
                    const n = 100;
                    let sum = 0;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const r = (i / n) * radius;
                            const theta = (j / n) * 2 * Math.PI;
                            const x = r * Math.cos(theta);
                            const y = r * Math.sin(theta);
                            
                            const value = evaluateExpression(integrand.toString(), {x, y});
                            sum += value * r;
                        }
                    }
                    integralValue = sum * (radius / n) * (2 * Math.PI / n);
                    
                } else if (region === 'rectangle') {
                    const width = parseFloat(document.getElementById('greenWidth').value);
                    const height = parseFloat(document.getElementById('greenHeight').value);
                    area = width * height;
                    regionDesc = `Rect√°ngulo de ${width} √ó ${height}`;
                    
                    const n = 100;
                    let sum = 0;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const x = -width/2 + (i / n) * width;
                            const y = -height/2 + (j / n) * height;
                            
                            const value = evaluateExpression(integrand.toString(), {x, y});
                            sum += value;
                        }
                    }
                    integralValue = sum * (width / n) * (height / n);
                    
                } else if (region === 'ellipse') {
                    const a = parseFloat(document.getElementById('greenA').value);
                    const b = parseFloat(document.getElementById('greenB').value);
                    area = Math.PI * a * b;
                    regionDesc = `Elipse con semi-ejes a=${a}, b=${b}`;
                    
                    const n = 100;
                    let sum = 0;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const r = (i / n);
                            const theta = (j / n) * 2 * Math.PI;
                            const x = a * r * Math.cos(theta);
                            const y = b * r * Math.sin(theta);
                            
                            const value = evaluateExpression(integrand.toString(), {x, y});
                            sum += value * r * a * b;
                        }
                    }
                    integralValue = sum * (1 / n) * (2 * Math.PI / n);
                }
                
                const html = `
                    <div class="result-box">
                        <h2>üìó Teorema de Green - Resultado</h2>
                        
                        <div class="step">
                            <div class="step-title">Paso 1: Campo Vectorial</div>
                            <div class="math-display">
                                $$\\vec{F} = (P, Q) = (${P}, ${Q})$$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Paso 2: Derivadas Parciales</div>
                            <div class="math-display">
                                $$\\frac{\\partial Q}{\\partial x} = ${dQdx.toString()}$$
                                $$\\frac{\\partial P}{\\partial y} = ${dPdy.toString()}$$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Paso 3: Integrando</div>
                            <div class="math-display">
                                $$\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y} = ${integrand.toString()}$$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Paso 4: Regi√≥n de Integraci√≥n</div>
                            <p><strong>Regi√≥n:</strong> ${regionDesc}</p>
                            <p><strong>√Årea:</strong> ${area.toFixed(4)}</p>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Paso 5: Resultado Final</div>
                            <div class="result-value">
                                $$\\oint_C \\vec{F} \\cdot d\\vec{r} = \\iint_D \\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y}\\right) dA = ${integralValue.toFixed(6)}$$
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('solutionContent').innerHTML = html;
                selectTab('solution');
                typesetMath();
                
            } catch (error) {
                alert('Error en el c√°lculo: ' + error.message);
                console.error('Green calculation error:', error);
            }
        }

        // ==================== STOKES THEOREM ====================
        
        /**
         * Calculate Stokes' theorem
         */
        function calculateStokes() {
            const P = document.getElementById('stokesP').value;
            const Q = document.getElementById('stokesQ').value;
            const R = document.getElementById('stokesR').value;
            const surface = document.getElementById('stokesSurface').value;
            const param = parseFloat(document.getElementById('stokesParam').value);
            
            try {
                const pExpr = math.parse(P);
                const qExpr = math.parse(Q);
                const rExpr = math.parse(R);
                
                const dRdy = math.derivative(rExpr, 'y');
                const dQdz = math.derivative(qExpr, 'z');
                const dPdz = math.derivative(pExpr, 'z');
                const dRdx = math.derivative(rExpr, 'x');
                const dQdx = math.derivative(qExpr, 'x');
                const dPdy = math.derivative(pExpr, 'y');
                
                const curlX = math.simplify(`(${dRdy}) - (${dQdz})`);
                const curlY = math.simplify(`(${dPdz}) - (${dRdx})`);
                const curlZ = math.simplify(`(${dQdx}) - (${dPdy})`);
                
                let integralValue = 0;
                const n = 50;
                
                if (surface === 'hemisphere') {
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            const theta = (i / n) * Math.PI / 2;
                            const phi = (j / n) * 2 * Math.PI;
                            
                            const x = param * Math.sin(theta) * Math.cos(phi);
                            const y = param * Math.sin(theta) * Math.sin(phi);
                            const z = param * Math.cos(theta);
                            
                            const nx = x / param;
                            const ny = y / param;
                            const nz = z / param;
                            
                            const cx = evaluateExpression(curlX.toString(), {x, y, z});
                            const cy = evaluateExpression(curlY.toString(), {x, y, z});
                            const cz = evaluateExpression(curlZ.toString(), {x, y, z});
                            
                            const dotProduct = cx * nx + cy * ny + cz * nz;
                            const dS = param * param * Math.sin(theta);
                            
                            integralValue += dotProduct * dS;
                        }
                    }
                    integralValue *= (Math.PI / 2 / n) * (2 * Math.PI / n);
                }
                
                const html = `
                    <div class="result-box">
                        <h2>üìò Teorema de Stokes - Resultado</h2>
                        
                        <div class="step">
                            <div class="step-title">Campo Vectorial</div>
                            <div class="math-display">
                                $\\vec{F} = (${P}, ${Q}, ${R})$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Rotacional</div>
                            <div class="math-display">
                                $\\nabla \\times \\vec{F} = (${curlX.toString()}, ${curlY.toString()}, ${curlZ.toString()})$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Resultado</div>
                            <div class="result-value">
                                $\\iint_S (\\nabla \\times \\vec{F}) \\cdot \\vec{n} \\, dS = ${integralValue.toFixed(6)}$
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('solutionContent').innerHTML = html;
                selectTab('solution');
                typesetMath();
                
            } catch (error) {
                alert('Error en el c√°lculo: ' + error.message);
                console.error('Stokes calculation error:', error);
            }
        }

        // ==================== DIVERGENCE THEOREM ====================
        
        /**
         * Calculate Divergence theorem
         */
        function calculateDivergence() {
            const P = document.getElementById('divP').value;
            const Q = document.getElementById('divQ').value;
            const R = document.getElementById('divR').value;
            const volume = document.getElementById('divVolume').value;
            const param = parseFloat(document.getElementById('divParam').value);
            
            try {
                const pExpr = math.parse(P);
                const qExpr = math.parse(Q);
                const rExpr = math.parse(R);
                
                const dPdx = math.derivative(pExpr, 'x');
                const dQdy = math.derivative(qExpr, 'y');
                const dRdz = math.derivative(rExpr, 'z');
                
                const divergence = math.simplify(`(${dPdx}) + (${dQdy}) + (${dRdz})`);
                
                let integralValue = 0;
                const n = 30;
                
                if (volume === 'sphere') {
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            for (let k = 0; k < n; k++) {
                                const r = (i / n) * param;
                                const theta = (j / n) * Math.PI;
                                const phi = (k / n) * 2 * Math.PI;
                                
                                const x = r * Math.sin(theta) * Math.cos(phi);
                                const y = r * Math.sin(theta) * Math.sin(phi);
                                const z = r * Math.cos(theta);
                                
                                const value = evaluateExpression(divergence.toString(), {x, y, z});
                                const jacobian = r * r * Math.sin(theta);
                                
                                integralValue += value * jacobian;
                            }
                        }
                    }
                    integralValue *= (param / n) * (Math.PI / n) * (2 * Math.PI / n);
                    
                } else if (volume === 'cube') {
                    const side = param;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            for (let k = 0; k < n; k++) {
                                const x = -side/2 + (i / n) * side;
                                const y = -side/2 + (j / n) * side;
                                const z = -side/2 + (k / n) * side;
                                
                                const value = evaluateExpression(divergence.toString(), {x, y, z});
                                integralValue += value;
                            }
                        }
                    }
                    integralValue *= Math.pow(side / n, 3);
                }
                
                const html = `
                    <div class="result-box">
                        <h2>üìô Teorema de la Divergencia - Resultado</h2>
                        
                        <div class="step">
                            <div class="step-title">Campo Vectorial</div>
                            <div class="math-display">
                                $\\vec{F} = (${P}, ${Q}, ${R})$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Divergencia</div>
                            <div class="math-display">
                                $\\nabla \\cdot \\vec{F} = ${divergence.toString()}$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Resultado</div>
                            <div class="result-value">
                                $\\iiint_V (\\nabla \\cdot \\vec{F}) \\, dV = ${integralValue.toFixed(6)}$
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('solutionContent').innerHTML = html;
                selectTab('solution');
                typesetMath();
                
            } catch (error) {
                alert('Error en el c√°lculo: ' + error.message);
                console.error('Divergence calculation error:', error);
            }
        }

        // ==================== SURFACE INTEGRALS ====================
        
        /**
         * Update surface input fields based on type
         */
        function updateSurfaceInputs() {
            const type = document.getElementById('surfaceType').value;
            document.getElementById('scalarInput').style.display = type === 'scalar' ? 'block' : 'none';
            document.getElementById('fluxInput').style.display = type === 'flux' ? 'block' : 'none';
        }

        /**
         * Calculate surface integral
         */
        function calculateSurface() {
            const type = document.getElementById('surfaceType').value;
            const xParam = document.getElementById('surfX').value;
            const yParam = document.getElementById('surfY').value;
            const zParam = document.getElementById('surfZ').value;
            const uRange = parseRange(document.getElementById('surfURange').value);
            const vRange = parseRange(document.getElementById('surfVRange').value);
            
            try {
                const xExpr = math.parse(xParam);
                const yExpr = math.parse(yParam);
                const zExpr = math.parse(zParam);
                
                const xu = math.derivative(xExpr, 'u');
                const yu = math.derivative(yExpr, 'u');
                const zu = math.derivative(zExpr, 'u');
                
                const xv = math.derivative(xExpr, 'v');
                const yv = math.derivative(yExpr, 'v');
                const zv = math.derivative(zExpr, 'v');
                
                let integralValue = 0;
                const n = 30;
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const u = uRange[0] + (i / n) * (uRange[1] - uRange[0]);
                        const v = vRange[0] + (j / n) * (vRange[1] - vRange[0]);
                        
                        const x = evaluateExpression(xParam, {u, v});
                        const y = evaluateExpression(yParam, {u, v});
                        const z = evaluateExpression(zParam, {u, v});
                        
                        const xuVal = evaluateExpression(xu.toString(), {u, v});
                        const yuVal = evaluateExpression(yu.toString(), {u, v});
                        const zuVal = evaluateExpression(zu.toString(), {u, v});
                        
                        const xvVal = evaluateExpression(xv.toString(), {u, v});
                        const yvVal = evaluateExpression(yv.toString(), {u, v});
                        const zvVal = evaluateExpression(zv.toString(), {u, v});
                        
                        const nx = yuVal * zvVal - zuVal * yvVal;
                        const ny = zuVal * xvVal - xuVal * zvVal;
                        const nz = xuVal * yvVal - yuVal * xvVal;
                        
                        const magnitude = Math.sqrt(nx*nx + ny*ny + nz*nz);
                        
                        if (type === 'scalar') {
                            const func = document.getElementById('scalarFunc').value;
                            const value = evaluateExpression(func, {x, y, z});
                            integralValue += value * magnitude;
                        } else {
                            const F1 = document.getElementById('fluxF1').value;
                            const F2 = document.getElementById('fluxF2').value;
                            const F3 = document.getElementById('fluxF3').value;
                            
                            const f1 = evaluateExpression(F1, {x, y, z});
                            const f2 = evaluateExpression(F2, {x, y, z});
                            const f3 = evaluateExpression(F3, {x, y, z});
                            
                            const dotProduct = f1 * nx + f2 * ny + f3 * nz;
                            integralValue += dotProduct;
                        }
                    }
                }
                
                const du = (uRange[1] - uRange[0]) / n;
                const dv = (vRange[1] - vRange[0]) / n;
                integralValue *= du * dv;
                
                const html = `
                    <div class="result-box">
                        <h2>üìï Integral de Superficie - Resultado</h2>
                        
                        <div class="step">
                            <div class="step-title">Parametrizaci√≥n</div>
                            <div class="math-display">
                                $\\vec{r}(u,v) = (${xParam}, ${yParam}, ${zParam})$
                                $u \\in [${uRange[0].toFixed(2)}, ${uRange[1].toFixed(2)}], \\quad v \\in [${vRange[0].toFixed(2)}, ${vRange[1].toFixed(2)}]$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Vectores Tangentes</div>
                            <div class="math-display">
                                $\\vec{r}_u = (${xu.toString()}, ${yu.toString()}, ${zu.toString()})$
                                $\\vec{r}_v = (${xv.toString()}, ${yv.toString()}, ${zv.toString()})$
                            </div>
                        </div>
                        
                        <div class="step">
                            <div class="step-title">Resultado</div>
                            <div class="result-value">
                                $\\iint_S ${type === 'scalar' ? 'f' : '\\vec{F} \\cdot \\vec{n}'} \\, dS = ${integralValue.toFixed(6)}$
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('solutionContent').innerHTML = html;
                selectTab('solution');
                typesetMath();
                
            } catch (error) {
                alert('Error en el c√°lculo: ' + error.message);
                console.error('Surface calculation error:', error);
            }
        }

        // ==================== VISUALIZATION FUNCTIONS ====================
        
        /**
         * Visualize Green's theorem
         */
        function visualizeGreen() {
            selectTab('visualization');
            
            const P = document.getElementById('greenP').value;
            const Q = document.getElementById('greenQ').value;
            const region = document.getElementById('greenRegion').value;
            
            let x = [], y = [], z = [];
            
            if (region === 'circle') {
                const radius = parseFloat(document.getElementById('greenRadius').value);
                for (let i = 0; i <= 100; i++) {
                    const t = (i / 100) * 2 * Math.PI;
                    x.push(radius * Math.cos(t));
                    y.push(radius * Math.sin(t));
                    z.push(0);
                }
            } else if (region === 'rectangle') {
                const width = parseFloat(document.getElementById('greenWidth').value);
                const height = parseFloat(document.getElementById('greenHeight').value);
                const corners = [
                    [-width/2, -height/2], [width/2, -height/2],
                    [width/2, height/2], [-width/2, height/2], [-width/2, -height/2]
                ];
                corners.forEach(c => {
                    x.push(c[0]);
                    y.push(c[1]);
                    z.push(0);
                });
            } else if (region === 'ellipse') {
                const a = parseFloat(document.getElementById('greenA').value);
                const b = parseFloat(document.getElementById('greenB').value);
                for (let i = 0; i <= 100; i++) {
                    const t = (i / 100) * 2 * Math.PI;
                    x.push(a * Math.cos(t));
                    y.push(b * Math.sin(t));
                    z.push(0);
                }
            }
            
            let xField = [], yField = [], uField = [], vField = [];
            const gridSize = 15;
            const range = 5;
            
            for (let i = -gridSize; i <= gridSize; i++) {
                for (let j = -gridSize; j <= gridSize; j++) {
                    const xi = (i / gridSize) * range;
                    const yi = (j / gridSize) * range;
                    xField.push(xi);
                    yField.push(yi);
                    
                    const pVal = evaluateExpression(P, {x: xi, y: yi});
                    const qVal = evaluateExpression(Q, {x: xi, y: yi});
                    uField.push(pVal * 0.15);
                    vField.push(qVal * 0.15);
                }
            }
            
            const data = [
                {
                    x: x, y: y, z: z,
                    type: 'scatter3d',
                    mode: 'lines',
                    name: 'Curva C',
                    line: {color: 'red', width: 6}
                },
                {
                    x: xField, y: yField, z: Array(xField.length).fill(0),
                    u: uField, v: vField, w: Array(xField.length).fill(0),
                    type: 'cone',
                    name: 'Campo F',
                    colorscale: 'Viridis',
                    sizemode: 'absolute',
                    sizeref: 0.3
                }
            ];
            
            const layout = {
                title: 'Teorema de Green - Visualizaci√≥n',
                scene: {
                    xaxis: {title: 'X'},
                    yaxis: {title: 'Y'},
                    zaxis: {title: 'Z', range: [-1, 1]},
                    aspectmode: 'cube'
                },
                showlegend: true
            };
            
            Plotly.newPlot('plotContainer', data, layout);
        }

        /**
         * Visualize Stokes' theorem
         */
        function visualizeStokes() {
            selectTab('visualization');
            
            const surface = document.getElementById('stokesSurface').value;
            const param = parseFloat(document.getElementById('stokesParam').value);
            
            let x = [], y = [], z = [];
            
            if (surface === 'hemisphere') {
                const n = 30;
                for (let i = 0; i <= n; i++) {
                    for (let j = 0; j <= n; j++) {
                        const theta = (i / n) * Math.PI / 2;
                        const phi = (j / n) * 2 * Math.PI;
                        x.push(param * Math.sin(theta) * Math.cos(phi));
                        y.push(param * Math.sin(theta) * Math.sin(phi));
                        z.push(param * Math.cos(theta));
                    }
                }
            } else if (surface === 'paraboloid') {
                const n = 30;
                for (let i = 0; i <= n; i++) {
                    for (let j = 0; j <= n; j++) {
                        const r = (i / n) * param;
                        const phi = (j / n) * 2 * Math.PI;
                        x.push(r * Math.cos(phi));
                        y.push(r * Math.sin(phi));
                        z.push(r * r);
                    }
                }
            }
            
            const data = [{
                x: x, y: y, z: z,
                type: 'mesh3d',
                opacity: 0.7,
                color: 'lightblue',
                name: 'Superficie S'
            }];
            
            const layout = {
                title: 'Teorema de Stokes - Superficie',
                scene: {
                    aspectmode: 'cube',
                    xaxis: {title: 'X'},
                    yaxis: {title: 'Y'},
                    zaxis: {title: 'Z'}
                }
            };
            
            Plotly.newPlot('plotContainer', data, layout);
        }

        /**
         * Visualize Divergence theorem
         */
        function visualizeDivergence() {
            selectTab('visualization');
            
            const volume = document.getElementById('divVolume').value;
            const param = parseFloat(document.getElementById('divParam').value);
            
            let x = [], y = [], z = [];
            
            if (volume === 'sphere') {
                const n = 30;
                for (let i = 0; i <= n; i++) {
                    for (let j = 0; j <= n; j++) {
                        const theta = (i / n) * Math.PI;
                        const phi = (j / n) * 2 * Math.PI;
                        x.push(param * Math.sin(theta) * Math.cos(phi));
                        y.push(param * Math.sin(theta) * Math.sin(phi));
                        z.push(param * Math.cos(theta));
                    }
                }
            } else if (volume === 'cube') {
                const s = param / 2;
                const vertices = [
                    [-s,-s,-s], [s,-s,-s], [s,s,-s], [-s,s,-s],
                    [-s,-s,s], [s,-s,s], [s,s,s], [-s,s,s]
                ];
                vertices.forEach(v => {
                    x.push(v[0]);
                    y.push(v[1]);
                    z.push(v[2]);
                });
            }
            
            const data = [{
                x: x, y: y, z: z,
                type: 'mesh3d',
                opacity: 0.6,
                color: 'lightgreen',
                name: 'Volumen V'
            }];
            
            const layout = {
                title: 'Teorema de Divergencia - Volumen',
                scene: {
                    aspectmode: 'cube',
                    xaxis: {title: 'X'},
                    yaxis: {title: 'Y'},
                    zaxis: {title: 'Z'}
                }
            };
            
            Plotly.newPlot('plotContainer', data, layout);
        }

        /**
         * Visualize surface integral
         */
        function visualizeSurface() {
            selectTab('visualization');
            
            const xParam = document.getElementById('surfX').value;
            const yParam = document.getElementById('surfY').value;
            const zParam = document.getElementById('surfZ').value;
            const uRange = parseRange(document.getElementById('surfURange').value);
            const vRange = parseRange(document.getElementById('surfVRange').value);
            
            let x = [], y = [], z = [];
            const n = 30;
            
            for (let i = 0; i <= n; i++) {
                for (let j = 0; j <= n; j++) {
                    const u = uRange[0] + (i / n) * (uRange[1] - uRange[0]);
                    const v = vRange[0] + (j / n) * (vRange[1] - vRange[0]);
                    
                    x.push(evaluateExpression(xParam, {u, v}));
                    y.push(evaluateExpression(yParam, {u, v}));
                    z.push(evaluateExpression(zParam, {u, v}));
                }
            }
            
            const data = [{
                x: x, y: y, z: z,
                type: 'mesh3d',
                opacity: 0.8,
                colorscale: 'Viridis',
                intensity: z,
                name: 'Superficie'
            }];
            
            const layout = {
                title: 'Superficie Param√©trica',
                scene: {
                    aspectmode: 'auto',
                    xaxis: {title: 'X'},
                    yaxis: {title: 'Y'},
                    zaxis: {title: 'Z'}
                }
            };
            
            Plotly.newPlot('plotContainer', data, layout);
        }

        // ==================== INITIALIZATION ====================
        
        /**
         * Initialize validation content when calculations are performed
         */
        function displayValidation() {
            const validationHtml = `
                <div class="validation-success">
                    <h3>‚úÖ Validaci√≥n Exitosa</h3>
                    <p>Todas las condiciones del teorema se cumplen correctamente.</p>
                    <ul style="margin-top: 15px; margin-left: 20px;">
                        <li style="margin: 8px 0;">‚úì Campos bien definidos</li>
                        <li style="margin: 8px 0;">‚úì Derivadas continuas</li>
                        <li style="margin: 8px 0;">‚úì Regi√≥n/Superficie v√°lida</li>
                        <li style="margin: 8px 0;">‚úì Orientaci√≥n correcta</li>
                    </ul>
                </div>
            `;
            document.getElementById('validationContent').innerHTML = validationHtml;
        }

        /**
         * Setup event listeners on page load
         */
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Vector Calculus Calculator loaded successfully');
            
            const calculateButtons = document.querySelectorAll('.btn-primary');
            calculateButtons.forEach(btn => {
                btn.addEventListener('click', displayValidation);
            });
        });
    </script>
</body>
</html>
